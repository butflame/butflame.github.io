---
layout: post
title: redis zset 实现：跳表
category: tech
tag: 数据结构
---

## redis有序集合的底层实现

本文将分别介绍[跳表](#skiplist)和redis的[有序集合](#zset)

<h3 id="skiplist">跳表</h3>

[参考文献](#skiplist-ref)
[介绍](#skiplist-introduction)
[代码实现](#skiplist-implementation)
[相关算法](#skiplist-algorithm)


<h4 id="skiplist-ref">参考文献</h4>

> Skip Lists: A Probabilistic Alternative to Balanced Trees ---- William Pugh

<h4 id="skiplist-introduction">跳表介绍</h4>

_跳表是一种可替代平衡树的数据结构。跳表实现概率期望上的平衡，而非如平衡数的严格平衡。基于此，跳表的插入和删除操作相较平衡树大大简化，也明显更快。_

<br/>

平衡树常用于实现字典、顺序列表等数据结构，当元素以随机顺序插入时表现很好，但在某些操作顺序下——例如插入已经排好序的数据，将使平衡树退化到很差的性能。_(译者注：将导致平衡树特性全部失效，插入操作类似链表，需要遍历完全部数据）_ 如果能将插入元素进行随机排列，平衡树绝大部分情况下能保证高效。然而绝大部分情况下请求需要即时返回，所以预先随机排列是不现实的。平衡树的算法通过重排列树中元素来保证树的平衡及其性能。

基于概率的跳表可作为平衡树的替换选项，跳表通过随机为元素决定层数来实现平衡。尽管跳表在最坏情况下的性能很差，但不存在某种输入序列能稳定的得到最坏情况（与快速排序随机选定pivot非常类似），跳表仅有极小的概率会变得显著不平衡。跳表的平衡性类似于随机插入生成的搜索树，然而跳表并不需要**“随机”**插入。

实现概率上的平衡要比维护严格的平衡简单很多，对于很多应用场景，跳表相比平衡树更符合直觉，对应的算法实现也更简单，这种实现上的简单性使其要达成效率提升、并保持稳定的高效会比使用平衡树或_自调节树_更简单。并且跳表的空间效率也非常优秀，对其中的每个元素，平均只需要1<sup>1/3</sup>个指针，并且不需要额外的信息来记录平衡性或优先级。

---

下面从简单链表开始，介绍跳表如何实现“基于概率的平衡”

![图1](https://wx1.sinaimg.cn/mw690/0087NSGggy1gj1klvrsnmj30qu0e9diu.jpg)

在简单链表中搜索，我们可能需要顺序检查所有元素（图1a）。  
如果链表是有序的，并且其中每隔一个节点具有指向下两个节点的指针（图1b），我们最多需要检查ceil(n/2) + 1个节点（其中n是链表长度）。  
同理，如果添加指向下4个节点的指针（图1c），我们最多需要检查ceil(n/4) + 2个节点。  
依此类推，如果所有第2<sup>i</sup>个节点都有指向下2<sup>i</sup>个节点的指针（图1d），我们需要检查的节点数将减少至cel(log<sub>2</sub>n)。这样的数据接口可用于快速查找，但是插入和删除将是灾难性的（每次元素的插入/删除都可能导致所有指针需要重新排布）

我们将额外具有k个出向指针（或称出度为k）的节点成为第k层的节点，如果第2<sup>i</sup>个节点都有指向下2<sup>i</sup>个节点的指针，那么节点的层数分布将遵循简单的规律：一层的节点占50%，二层节点占25%，三层节点占12.5%等等。

**如果保持这样的比例，但节点的层数是随机确定的会怎么样呢？（图1e）**

一个节点的第i个向后的指针，指向第i层或更高层的下一个节点，而不是固定的下2<sup>i-1</sup>个节点，这样使得节点插入/删除时仅需要进行本地的修改（将该节点插入到第1层到第i层的每个链表中/从第1层到第i层的每个链表中移除），而每个节点的层数是在插入时_随机_（并非绝对随机，而是遵循上述的比例确定）确定的，并且永远不需要改变。某些特定的层数分配可能导致执行效率极差，但这种情况是极少见的。

这种数据结构在链表的基础上，具备额外的指针以在搜索中跳过部分节点以提高搜索效率，作者将其命名为跳表。

<h4 id="skiplist-implementation">跳表代码实现</h4>



<h4 id="skiplist-algorithm">跳表相关算法</h4>


施工中

---

<h3 id="zset">redis的有序集合</h3>



